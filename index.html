<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture-Controlled Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #video-container { position: fixed; bottom: 20px; left: 20px; width: 160px; height: 120px; border: 2px solid #444; border-radius: 8px; overflow: hidden; transform: scaleX(-1); }
        #webcam { width: 100%; height: 100%; object-fit: cover; }
        #fullscreen-btn { position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: rgba(255,255,255,0.1); color: white; border: 1px solid white; cursor: pointer; backdrop-filter: blur(5px); transition: 0.3s; }
        #fullscreen-btn:hover { background: white; color: black; }
        canvas { display: block; }
    </style>
</head>
<body>

    <button id="fullscreen-btn">GO FULLSCREEN</button>
    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <script>
        /**
         * INITIAL SETUP & VARIABLES
         */
        let scene, camera, renderer, particles, geometry, material;
        let particleCount = 15000;
        let expansionFactor = 1;
        const videoElement = document.getElementById('webcam');
        
        const params = {
            shape: 'Galaxy',
            color: '#00ccff',
            particleSize: 0.05,
            rotationSpeed: 0.002
        };

        initThree();
        initMediaPipe();
        initUI();
        animate();

        /**
         * THREE.JS CORE
         */
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            createParticles();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            document.getElementById('fullscreen-btn').onclick = () => {
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            };
        }

        function createParticles() {
            if (particles) scene.remove(particles);

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const initialPositions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                const i3 = i * 3;

                // Shape math
                if (params.shape === 'Galaxy') {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 4;
                    const spiral = radius * 2;
                    x = Math.cos(angle + spiral) * radius;
                    y = (Math.random() - 0.5) * 0.5;
                    z = Math.sin(angle + spiral) * radius;
                } else if (params.shape === 'Heart') {
                    const t = Math.random() * Math.PI * 2;
                    x = 1.6 * Math.pow(Math.sin(t), 3);
                    y = 1.3 * Math.cos(t) - 0.5 * Math.cos(2*t) - 0.2 * Math.cos(3*t) - 0.1 * Math.cos(4*t);
                    z = (Math.random() - 0.5) * 0.5;
                    x *= 0.8; y *= 0.8;
                } else if (params.shape === 'Flower') {
                    const t = Math.random() * Math.PI * 2;
                    const r = 2 * Math.cos(5 * t);
                    x = r * Math.cos(t);
                    y = r * Math.sin(t);
                    z = (Math.random() - 0.5) * 0.5;
                } else { // Saturn / Sphere
                    const phi = Math.acos(-1 + (2 * i) / particleCount);
                    const theta = Math.sqrt(particleCount * Math.PI) * phi;
                    x = 2 * Math.cos(theta) * Math.sin(phi);
                    y = 2 * Math.sin(theta) * Math.sin(phi);
                    z = 2 * Math.cos(phi);
                }

                initialPositions[i3] = x;
                initialPositions[i3 + 1] = y;
                initialPositions[i3 + 2] = z;
                positions[i3] = x;
                positions[i3+1] = y;
                positions[i3+2] = z;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('initialPos', new THREE.BufferAttribute(initialPositions, 3));

            material = new THREE.PointsMaterial({
                color: params.color,
                size: params.particleSize,
                transparent: true,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        /**
         * HAND GESTURE LOGIC (MediaPipe)
         */
        function initMediaPipe() {
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // Simple gesture: Distance between thumb tip(4) and pinky tip(20)
                    const dx = landmarks[4].x - landmarks[20].x;
                    const dy = landmarks[4].y - landmarks[20].y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Smoothly map distance (0.1 - 0.5) to expansion (1.0 - 3.0)
                    const targetExpansion = THREE.MathUtils.mapLinear(distance, 0.1, 0.5, 1.0, 4.0);
                    expansionFactor = THREE.MathUtils.lerp(expansionFactor, targetExpansion, 0.1);
                } else {
                    // Shrink back when no hand detected
                    expansionFactor = THREE.MathUtils.lerp(expansionFactor, 1.0, 0.05);
                }
            });

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            camera.start();
        }

        /**
         * UI CONTROLS
         */
        function initUI() {
            const gui = new dat.GUI({ width: 300 });
            gui.add(params, 'shape', ['Galaxy', 'Heart', 'Flower', 'Saturn']).name('Particle Shape').onChange(createParticles);
            gui.addColor(params, 'color').name('Main Color').onChange(v => material.color.set(v));
            gui.add(params, 'particleSize', 0.01, 0.2).name('Particle Size').onChange(v => material.size = v);
            gui.add(params, 'rotationSpeed', 0, 0.01).name('Rotation Speed');
        }

        /**
         * ANIMATION LOOP
         */
        function animate() {
            requestAnimationFrame(animate);

            if (particles) {
                particles.rotation.y += params.rotationSpeed;
                
                const positions = geometry.attributes.position.array;
                const initialPos = geometry.attributes.initialPos.array;

                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    // Apply expansion factor based on hand gesture
                    positions[i3] = initialPos[i3] * expansionFactor;
                    positions[i3+1] = initialPos[i3+1] * expansionFactor;
                    positions[i3+2] = initialPos[i3+2] * expansionFactor;
                }
                geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
